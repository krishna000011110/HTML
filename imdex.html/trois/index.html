<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>trois</title>

  <style>
   body, html {
  margin: 0;
}
canvas {
  display: block;
}

  </style>

</head>
<body>

  <div id="app">
  <renderer ref="renderer" resize="window" :auto-clear="false" mouse-move mouse-raycast orbit-ctrl>
    <camera :position="{ z: 300 }"></camera>
    <scene>
      <ambient-light color="#808080"></ambient-light>
      <point-light color="#ff6000"></point-light>
      <point-light color="#0060ff" :intensity="0.5" ref="light"></point-light>
      <point-light color="#ff6000" :intensity="0.5" :position="{ x: 100}"></point-light>
      <point-light color="#0000ff" :intensity="0.5" :position="{ x: -100}"></point-light>

      <instanced-mesh ref="imesh" :count="NUM_INSTANCES">
        <box-geometry :width="2" :height="2" :depth="10"></box-geometry>
        <standard-material transparent :opacity="0.9" :metalness="0.8" :roughness="0.5"></standard-material>
      </instanced-mesh>
    </scene>

    <effect-composer>
      <render-pass></render-pass>
      <unreal-bloom-pass :strength="1"></unreal-bloom-pass>
      <halftone-pass :radius="1" :scatter="0"></halftone-pass>
    </effect-composer>
  </renderer>
</div>


  <script type="module">
import { createApp } from 'https://unpkg.com/troisjs@0.1.10/build/trois.module.cdn.min.js';
import { Object3D, MathUtils, Vector3 } from 'https://unpkg.com/three@0.125.2/build/three.module.js';

const { randFloat: rnd, randFloatSpread: rndFS } = MathUtils;

createApp({
  setup() {
    const NUM_INSTANCES = 2000;
    const instances = [];
    const target = new Vector3();
    const dummyO = new Object3D();
    const dummyV = new Vector3();

    for (let i = 0; i < NUM_INSTANCES; i++) {
      instances.push({
        position: new Vector3(rndFS(200), rndFS(200), rndFS(200)),
        scale: rnd(0.2, 1),
        scaleZ: rnd(0.1, 1),
        velocity: new Vector3(rndFS(2), rndFS(2), rndFS(2)),
        attraction: 0.03 + rnd(-0.01, 0.01),
        vlimit: 1.2 + rnd(-0.1, 0.1),
      });
    }

    return { NUM_INSTANCES, instances, target, dummyO, dummyV };
  },
  mounted() {
    this.renderer = this.$refs.renderer;
    this.imesh = this.$refs.imesh.mesh;
    this.light = this.$refs.light.light;
    this.init();
  },
  methods: {
    init() {
      for (let i = 0; i < this.NUM_INSTANCES; i++) {
        const { position, scale, scaleZ } = this.instances[i];
        this.dummyO.position.copy(position);
        this.dummyO.scale.set(scale, scale, scaleZ);
        this.dummyO.updateMatrix();
        this.imesh.setMatrixAt(i, this.dummyO.matrix);
      }
      this.imesh.instanceMatrix.needsUpdate = true;
      this.renderer.onBeforeRender(this.animate);
    },
    animate() {
      this.target.copy(this.renderer.three.mouseV3);
      this.light.position.copy(this.target);

      for (let i = 0; i < this.NUM_INSTANCES; i++) {
        const { position, scale, scaleZ, velocity, attraction, vlimit } = this.instances[i];
        this.dummyV.copy(this.target).sub(position).normalize().multiplyScalar(attraction);
        velocity.add(this.dummyV).clampScalar(-vlimit, vlimit);
        position.add(velocity);

        this.dummyO.position.copy(position);
        this.dummyO.scale.set(scale, scale, scaleZ);
        this.dummyO.lookAt(this.dummyV.copy(position).add(velocity));
        this.dummyO.updateMatrix();
        this.imesh.setMatrixAt(i, this.dummyO.matrix);
      }
      this.imesh.instanceMatrix.needsUpdate = true;
    },
  },
}).mount('#app');
</script>


</body>
</html>
