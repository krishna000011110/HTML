<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>

    <html lang="en">
	<head>
		<style>
			body {
				margin: 0;
			}
		</style>
		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js",
						"jsm/": "https://cdn.jsdelivr.net/npm/three@0.161/examples/jsm/"
				}
			}
		</script>
	</head>
	<body>
	</body>
</html>

<script type="module">

import * as THREE from "three";
import { OrbitControls } from "jsm/controls/OrbitControls.js";
import { EffectComposer } from "jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "jsm/postprocessing/UnrealBloomPass.js";

const w = window.innerWidth;
const h = window.innerHeight;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.7);

const camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer();
renderer.setSize(w, h);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.03;

const renderScene = new RenderPass(scene, camera);
const bloomPass = new UnrealBloomPass(new THREE.Vector2(w, h), 1.5, 0.4, 100);
bloomPass.threshold = 0.002;
bloomPass.strength = 7;
bloomPass.radius = 0;

const composer = new EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

const curvePath = [
	-0.15439987182617188, -4.138374328613281, -3.073897361755371,
	-0.869240403175354, -5.335973739624023, -2.7324037551879883,
	-1.633371353149414, -5.862466812133789, -1.7560205459594727
];

const pointst = [];
for (let p = 0; p < curvePath.length; p += 3) {
	pointst.push(
		new THREE.Vector3(curvePath[p], curvePath[p + 1], curvePath[p + 2])
	);
}

const spline = new THREE.CatmullRomCurve3(pointst);

function updateCamera(t) {
	const time = t * 0.1;
	const loopTime = 20 * 400;
	const p = (time % loopTime) / loopTime;
	const pos = spline.getPointAt(p);
	const lookAt = spline.getPointAt((p + 0.01) % 1);
	camera.position.copy(pos);
	camera.lookAt(lookAt);
}

function animate(t = 0) {
	requestAnimationFrame(animate);
	updateCamera(t);
	composer.render(scene, camera);
	controls.update();
}

animate();

function handleWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

window.addEventListener("resize", handleWindowResize, false);

</script>

</body>
</html>
